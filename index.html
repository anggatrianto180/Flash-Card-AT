<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flashcard App with Firebase</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- PapaParse for CSV parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/papaparse/5.3.2/papaparse.min.js"></script>
    <!-- SheetJS for Excel (.xlsx/.xls) parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- PWA manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#4f46e5">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Fixed footer-style Start Studying button: centered and full-width matching container */
        .fixed-start-session {
            position: fixed;
            bottom: 0; /* flush to bottom edge */
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            padding: 0; /* no horizontal padding so button can reach edges */
            z-index: 60; /* sit on top of other content */
            pointer-events: auto;
        }

        /* The button fills the container width but respects a max-width to match the app container */
        .fixed-start-session .start-btn {
            width: 100vw; /* full viewport width */
            max-width: none;
            border-radius: 0; /* flush edges */
            padding: 1rem 0; /* vertical padding, full-width button */
            font-size: 1rem;
            font-weight: 700;
            margin: 0; /* ensure no gaps */
        }

        /* Theme-aware colors: match the card container while remaining visible against page background */
        .fixed-start-session .start-btn {
            /* light theme: match card front (white) with dark text and subtle border/shadow to stand out */
            background-color: #ffffff;
            color: #0f172a; /* dark text */
            border: 1px solid rgba(15, 23, 42, 0.06);
            box-shadow: 0 6px 18px rgba(15,23,42,0.06);
        }
        .dark .fixed-start-session .start-btn {
            /* dark theme: match dark card surface but ensure contrast via border and slightly lighter text */
            background-color: #1f2937; /* gray-800 */
            color: #e5e7eb;
            border: 1px solid rgba(255,255,255,0.04);
            box-shadow: 0 6px 18px rgba(2,6,23,0.45);
        }
        .fixed-start-session .start-btn:hover {
            transform: translateY(-1px) scale(1.01);
            filter: none;
        }
        /* Custom styles for the card flip animation */
        .card-inner {
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .is-flipped {
            transform: rotateY(180deg);
        }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden; /* Safari */
            backface-visibility: hidden;
        }
        .card-back {
             transform: rotateY(180deg);
        }
        /* Modal styles */
        .modal {
            transition: opacity 0.25s ease;
        }
        .modal-content {
             transition: transform 0.25s ease;
        }
    </style>
    <script>
        // Apply dark mode immediately from localStorage to prevent flashing
        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
          document.documentElement.classList.add('dark')
        } else {
          document.documentElement.classList.remove('dark')
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 transition-colors duration-300">

    <div id="app" class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
        <header id="main-header" class="text-left mb-8 relative">
            <h3 class="text-3xl font-bold text-indigo-600 dark:text-indigo-400">Flashcard AT</h3>
            <button id="theme-toggle" class="absolute top-0 right-0 p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors">
                <i class="fas fa-sun" id="theme-toggle-light-icon"></i>
                <i class="fas fa-moon hidden" id="theme-toggle-dark-icon"></i>
            </button>
        </header>

        <!-- Main content area -->
        <main id="main-content">
            <!-- Category List View -->
            <div id="category-list-view">
                 <div class="flex justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold">Select Your Category</h2>
                    <button id="show-add-category-modal-btn" class="bg-indigo-600 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-lg hover:bg-indigo-700 transition-transform transform hover:scale-110">
                        <i class="fas fa-plus fa-lg"></i>
                    </button>
                </div>
                <div id="category-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Category cards will be injected here -->
                </div>
            </div>

            <!-- Deck List View -->
            <div id="deck-list-view" class="hidden">
                 <div class="flex justify-between items-center mb-4">
                    <div>
                        <button id="back-to-categories-btn" class="text-sm text-indigo-600 dark:text-indigo-400 hover:underline mb-2"><i class="fas fa-arrow-left mr-1"></i> Back to Categories</button>
                        <h2 id="category-title" class="text-2xl font-semibold"></h2>
                    </div>
                    <button id="show-add-deck-modal-btn" class="bg-indigo-600 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-lg hover:bg-indigo-700 transition-transform transform hover:scale-110">
                        <i class="fas fa-plus fa-lg"></i>
                    </button>
                </div>
                <div id="deck-list" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
                    <!-- Deck cards will be injected here -->
                </div>
            </div>

            <!-- Flashcard Review View -->
            <div id="card-review-view" class="hidden">
                <div class="flex justify-between items-center mb-4 flex-wrap gap-2">
                    <div class="flex items-center gap-3">
                        <h2 id="deck-title" class="text-2xl font-semibold"></h2>
                        <button id="edit-deck-name-btn" class="text-gray-400 hover:text-indigo-600"><i class="fas fa-pencil-alt"></i></button>
                        <button id="delete-deck-btn" class="text-gray-400 hover:text-red-600"><i class="fas fa-trash-alt"></i></button>
                    </div>
                    <button id="back-to-decks-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors text-sm">
                        <i class="fas fa-chevron-left mr-2"></i> Back to Decks
                    </button>
                </div>
                
                <div class="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-md mb-6">
                    <h3 class="font-semibold text-lg mb-2">Cards</h3>
                    <div class="flex items-center gap-2 mb-3">
                        <button id="open-add-card-modal-btn" class="bg-green-600 text-white font-semibold px-4 py-2 rounded-lg hover:bg-green-700">+ Add Card</button>
                        <div class="flex-1"></div>
                    </div>
                    <div class="mt-0 relative">
                        <input type="text" id="search-input" class="w-full p-3 pl-10 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 rounded-lg" placeholder="Search cards...">
                        <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
                    </div>
                    <div class="mt-4 flex gap-2 justify-end">
                        <input type="file" id="import-csv-input" class="hidden" accept=".csv,.xlsx,.xls">
                        <button id="import-cards-btn" class="text-sm bg-blue-500 text-white font-semibold px-4 py-2 rounded-lg hover:bg-blue-600"><i class="fas fa-upload mr-2"></i>Import (CSV)</button>
                        <button id="export-cards-btn" class="text-sm bg-gray-500 text-white font-semibold px-4 py-2 rounded-lg hover:bg-gray-600"><i class="fas fa-download mr-2"></i>Export (CSV)</button>
                    </div>
                </div>

                <!-- Add Card Modal -->
                <div id="add-card-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
                    <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                        <h3 class="text-xl font-semibold mb-4">Add New Card</h3>
                        <div>
                            <label for="add-card-front" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Front</label>
                            <textarea id="add-card-front" rows="3" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3" placeholder="Front (Question)..."></textarea>
                        </div>
                        <div class="mt-4">
                            <label for="add-card-back" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Back</label>
                            <textarea id="add-card-back" rows="3" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3" placeholder="Back (Answer)..."></textarea>
                        </div>
                        <div class="mt-6 flex justify-end gap-3">
                            <button id="cancel-add-card-modal-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                            <button id="save-add-card-modal-btn" class="bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700">Add</button>
                        </div>
                    </div>
                </div>

                <!-- Edit Category Modal -->
                <div id="edit-category-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0 z-50">
                    <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                        <h3 class="text-xl font-semibold mb-4">Edit Category Name</h3>
                        <div>
                            <label for="edit-category-name-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Category Name</label>
                            <input type="text" id="edit-category-name-input" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3">
                        </div>
                        <div class="mt-6 flex justify-end gap-3">
                            <button id="cancel-edit-category-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                            <button id="save-edit-category-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
                        </div>
                    </div>
                </div>
                
                <div id="start-session-container" class="text-center my-0 fixed-start-session">
                    <button id="start-session-btn" class="start-btn transition-transform transform hover:scale-105 shadow-lg">
                        Start Studying <i class="fas fa-rocket ml-2"></i>
                    </button>
                </div>

                <div class="bg-white dark:bg-gray-800 p-4 rounded-xl shadow-md mb-6">
                    <h3 class="font-semibold text-lg mb-2">Card List</h3>
                    <div id="card-list" class="space-y-2 max-h-60 overflow-y-auto"></div>
                    <div id="deck-stats" class="mt-4 flex justify-around text-center p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg border-t dark:border-gray-700">
                        <!-- Stats will be injected here -->
                    </div>
                </div>
            </div>
        </main>

        <!-- Study Focus View -->
        <div id="study-focus-view" class="hidden">
            <div class="flex justify-end mb-4">
                <button id="exit-focus-mode-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600">
                    <i class="fas fa-times mr-2"></i> Exit Focus Mode
                </button>
            </div>
            <div id="study-session-view">
                <div class="flex flex-col sm:flex-row gap-4 mb-6">
                    <div class="flex-grow"></div>
                    <button id="shuffle-btn" class="bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 px-4 py-2 rounded-lg hover:bg-gray-50 dark:hover:bg-gray-700">
                        <i class="fas fa-random mr-2"></i> Shuffle Cards
                    </button>
                </div>

                <div id="card-progress-container" class="mb-4">
                    <p id="card-progress-text" class="text-center text-gray-600 dark:text-gray-400 mb-1"></p>
                    <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5">
                        <div id="card-progress-bar" class="bg-indigo-600 dark:bg-indigo-400 h-2.5 rounded-full" style="width: 0%"></div>
                    </div>
                </div>

                <div id="flashcard-container" class="perspective-1000 w-full h-80 mb-6">
                    <div id="flashcard-inner" class="card-inner relative w-full h-full">
                        <div id="card-front" class="card-face bg-white dark:bg-gray-800 rounded-xl shadow-lg flex items-center justify-center p-6 text-center">
                            <p class="text-3xl font-medium"></p>
                        </div>
                        <div id="card-back" class="card-back card-face bg-indigo-500 dark:bg-indigo-600 text-white rounded-xl shadow-lg flex flex-col items-center justify-center p-6 text-center">
                            <p class="text-2xl mb-4"></p>
                            <button id="generate-example-btn" class="bg-white text-indigo-600 font-semibold px-4 py-2 rounded-lg hover:bg-gray-200">
                                <span id="gen-example-text">âœ¨ Generate Example</span>
                                <div id="gen-example-spinner" class="hidden animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-indigo-600 ml-2"></div>
                            </button>
                            <div id="example-sentence-container" class="mt-4 text-left text-sm w-full bg-indigo-600/80 p-3 rounded-lg hidden"></div>
                        </div>
                    </div>
                </div>

                <div id="action-buttons" class="hidden grid grid-cols-3 gap-4">
                    <button data-status="again" class="status-btn bg-red-500 text-white py-4 rounded-lg font-semibold text-lg hover:bg-red-600">Again</button>
                    <button data-status="good" class="status-btn bg-blue-500 text-white py-4 rounded-lg font-semibold text-lg hover:bg-blue-600">Good</button>
                    <button data-status="easy" class="status-btn bg-green-500 text-white py-4 rounded-lg font-semibold text-lg hover:bg-green-600">Easy</button>
                </div>
                
                <div id="completion-message" class="hidden text-center bg-green-100 dark:bg-green-900/50 text-green-800 dark:text-green-300 p-6 rounded-xl">
                    <h3 class="text-2xl font-semibold">ðŸŽ‰ Congratulations!</h3>
                    <p class="mt-2">You have finished all cards in this deck.</p>
                    <div class="mt-4 flex justify-center gap-3">
                        <button id="restart-deck-btn" class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700">Restart Deck</button>
                        <button id="back-to-cards-after-study-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-6 py-2 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600">Back to Cards</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Modals -->
        <div id="add-category-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
            <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                <h3 class="text-xl font-semibold mb-4">Create New Category</h3>
                <div>
                    <label for="add-category-name-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Category Name</label>
                    <input type="text" id="add-category-name-input" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3">
                </div>
                <div class="mt-6 flex justify-end gap-3">
                    <button id="cancel-add-category-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                    <button id="save-add-category-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
                </div>
            </div>
        </div>

        <div id="add-deck-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
            <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                <h3 class="text-xl font-semibold mb-4">Create New Deck</h3>
                <div>
                    <label for="add-deck-name-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Deck Name</label>
                    <input type="text" id="add-deck-name-input" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3">
                </div>
                <div class="mt-6 flex justify-end gap-3">
                    <button id="cancel-add-deck-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                    <button id="save-add-deck-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
                </div>
            </div>
        </div>

        <div id="edit-card-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
            <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                <h3 class="text-xl font-semibold mb-4">Edit Card</h3>
                    <div class="space-y-4">
                    <div>
                        <label for="edit-card-front" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Front</label>
                        <textarea id="edit-card-front" rows="3" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3"></textarea>
                    </div>
                    <div>
                        <label for="edit-card-back" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Back</label>
                        <textarea id="edit-card-back" rows="3" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3"></textarea>
                    </div>
                </div>
                <div class="mt-6 flex justify-end gap-3">
                    <button id="cancel-edit-card-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                    <button id="save-edit-card-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
                </div>
            </div>
        </div>

        <div id="edit-deck-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
            <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                <h3 class="text-xl font-semibold mb-4">Edit Deck Name</h3>
                <div>
                    <label for="edit-deck-name-input" class="block text-sm font-medium text-gray-700 dark:text-gray-300">Deck Name</label>
                    <input type="text" id="edit-deck-name-input" class="mt-1 block w-full border border-gray-300 dark:border-gray-600 bg-gray-50 dark:bg-gray-700 rounded-md shadow-sm py-2 px-3">
                </div>
                <div class="mt-6 flex justify-end gap-3">
                    <button id="cancel-edit-deck-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                    <button id="save-edit-deck-btn" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700">Save</button>
                </div>
            </div>
        </div>
        
        <div id="confirmation-modal" class="modal fixed inset-0 bg-gray-900 bg-opacity-50 flex items-center justify-center p-4 hidden opacity-0">
            <div class="modal-content bg-white dark:bg-gray-800 rounded-lg p-6 w-full max-w-md transform scale-95">
                <h3 class="text-xl font-semibold mb-4">Confirm Deletion</h3>
                <p id="confirmation-message" class="text-gray-600 dark:text-gray-300"></p>
                <div class="mt-6 flex justify-end gap-3">
                    <button id="cancel-confirmation-btn" class="bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 px-4 py-2 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Cancel</button>
                    <button id="confirm-delete-btn" class="bg-red-600 text-white px-4 py-2 rounded-md hover:bg-red-700">Delete</button>
                </div>
            </div>
        </div>

    </div>
    
    <script type="module">
        // Firebase Imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, updateDoc, arrayUnion, onSnapshot, query, deleteDoc, arrayRemove, getDocs, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const firebaseConfig = {
          apiKey: "AIzaSyA-ZuRnUy3_3-vR4mkZKqI3QeaVEFw-qPo",
          authDomain: "flash-card-b4d35.firebaseapp.com",
          projectId: "flash-card-b4d35",
          storageBucket: "flash-card-b4d35.firebasestorage.app",
          messagingSenderId: "467080205468",
          appId: "1:467080205468:web:0aa9350657f3d503f00959"
        };
        
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);

        // --- App State (Global within module) ---
        let allCategories = {};
        let currentCategoryName = '';
        let currentDeckName = '';
        let userIsAuthenticated = false;
        let unsubscribeDecksListener = null;

        // --- Firebase Data Handling Functions (defined globally in the module) ---
        async function addCategoryToFirestore(categoryName) {
            if (!userIsAuthenticated || !categoryName) return;
            try {
                const newCategoryRef = doc(collection(db, 'categories'), categoryName);
                await setDoc(newCategoryRef, { name: categoryName });
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) { console.error("Error adding category: ", error); }
        }

        // Rename category by copying all decks to new category document then deleting old
        async function updateCategoryNameInFirestore(oldName, newName) {
            if (!userIsAuthenticated || !oldName || !newName || oldName === newName) return false;
            // Prevent accidental overwrite
            if (allCategories[newName]) {
                alert('A category with that name already exists. Choose a different name.');
                return false;
            }
            try {
                // Create the new category document
                const newCategoryRef = doc(collection(db, 'categories'), newName);
                await setDoc(newCategoryRef, { name: newName });

                // Copy decks from Firestore (safer than relying solely on in-memory state)
                const decksRef = collection(db, 'categories', oldName, 'decks');
                const deckSnapshot = await getDocs(decksRef);
                const copyPromises = [];
                deckSnapshot.forEach(deckDoc => {
                    const deckId = deckDoc.id;
                    const deckData = deckDoc.data();
                    const newDeckRef = doc(collection(db, 'categories', newName, 'decks'), deckId);
                    copyPromises.push(setDoc(newDeckRef, deckData));
                });
                await Promise.all(copyPromises);

                // Delete old category and its decks
                await deleteCategoryFromFirestore(oldName);

                // Update local state and UI immediately for responsiveness
                allCategories[newName] = allCategories[oldName] || {};
                delete allCategories[oldName];
                renderCategories();

                // If user currently had the old category selected, switch to the new one
                if (currentCategoryName === oldName) {
                    currentCategoryName = newName;
                    // Re-listen to decks for the new category
                    listenToDecks(newName);
                    // If we were viewing decks, render them
                    if (!deckListView.classList.contains('hidden')) {
                        renderDecks(newName);
                    }
                }

                alert('Category renamed successfully.');
                return true;
            } catch (err) {
                console.error('Failed to rename category:', err);
                alert('Failed to rename category. See console for details.');
                return false;
            }
        }

        async function deleteCategoryFromFirestore(categoryName) {
            if (!userIsAuthenticated || !categoryName) return;
            try {
                const decksRef = collection(db, 'categories', categoryName, 'decks');
                const deckSnapshot = await getDocs(decksRef);
                const deletePromises = [];
                deckSnapshot.forEach(deckDoc => {
                    deletePromises.push(deleteDoc(deckDoc.ref));
                });
                await Promise.all(deletePromises);

                const categoryRef = doc(collection(db, 'categories'), categoryName);
                await deleteDoc(categoryRef);
                // update local UI/state after delete
                delete allCategories[categoryName];
                renderCategories();
            } catch (error) {
                console.error("Error deleting category and its decks: ", error);
            }
        }

        async function addDeckToFirestore(categoryName, deckName) {
            if (!userIsAuthenticated || !categoryName || !deckName) return;
            try {
                const newDeckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await setDoc(newDeckRef, { name: deckName, cards: [], lastStudied: null });
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) { console.error("Error adding deck: ", error); }
        }

        async function deleteDeckFromFirestore(categoryName, deckName) {
            if (!userIsAuthenticated || !categoryName || !deckName) return;
            try {
                const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await deleteDoc(deckRef);
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) { console.error("Error deleting deck: ", error); }
        }
        
        async function updateDeckNameInFirestore(categoryName, oldName, newName) {
            if (!userIsAuthenticated || !oldName || !newName || oldName === newName) return;
            if (allCategories[categoryName][newName]) {
                alert('A deck with this name already exists in this category.');
                return;
            }
            try {
                const oldDeckData = allCategories[categoryName][oldName];
                const newDeckRef = doc(collection(db, 'categories', categoryName, 'decks'), newName);
                await setDoc(newDeckRef, { ...oldDeckData, name: newName });
                
                const oldDeckRef = doc(collection(db, 'categories', categoryName, 'decks'), oldName);
                await deleteDoc(oldDeckRef);
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) { console.error("Error updating deck name: ", error); }
        }

        async function deleteCardFromFirestore(categoryName, deckName, cardToDelete) {
            if (!userIsAuthenticated) return;
            try {
                const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await updateDoc(deckRef, { cards: arrayRemove(cardToDelete) });
                await refreshCategoryFromFirestore(categoryName);
            } catch(error) { console.error("Error deleting card: ", error); }
        }

        async function updateCardInFirestore(categoryName, deckName, oldCard, newCard) {
            if (!userIsAuthenticated) return;
            try {
                const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await updateDoc(deckRef, { cards: arrayRemove(oldCard) });
                await updateDoc(deckRef, { cards: arrayUnion(newCard) });
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) { console.error("Error updating card: ", error); }
        }

        async function addCardToFirestore(categoryName, deckName, front, back) {
            if (!userIsAuthenticated || !categoryName || !deckName || !front || !back) return;
            try {
                const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await updateDoc(deckRef, {
                    cards: arrayUnion({ front, back, status: 'new' })
                });
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) {
                console.error("Error adding card: ", error);
            }
        }
        
        async function updateCardStatusInFirestore(categoryName, deckName, cardIndex, newStatus) {
            if (!userIsAuthenticated) return;
            try {
                const deckData = allCategories[categoryName][deckName];
                const updatedCards = [...deckData.cards];
                if (updatedCards[cardIndex]) {
                    updatedCards[cardIndex].status = newStatus;
                    const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                    await updateDoc(deckRef, { cards: updatedCards });
                    await refreshCategoryFromFirestore(categoryName);
                }
            } catch (error) {
                console.error("Error updating card status:", error);
            }
        }

        async function updateDeckLastStudied(categoryName, deckName) {
            if (!userIsAuthenticated) return;
            try {
                const deckRef = doc(collection(db, 'categories', categoryName, 'decks'), deckName);
                await updateDoc(deckRef, { lastStudied: serverTimestamp() });
                await refreshCategoryFromFirestore(categoryName);
            } catch (error) {
                console.error("Error updating last studied time:", error);
            }
        }

        // Refresh a specific category's decks/cards from Firestore and update UI immediately
        async function refreshCategoryFromFirestore(categoryName) {
            if (!categoryName || !userIsAuthenticated) return;
            try {
                const decksRef = collection(db, 'categories', categoryName, 'decks');
                const snapshot = await getDocs(decksRef);
                const decks = {};
                snapshot.forEach(docSnap => {
                    decks[docSnap.id] = docSnap.data();
                });
                allCategories[categoryName] = decks;
                // Re-render UI
                renderCategories();
                if (!deckListView.classList.contains('hidden') && currentCategoryName === categoryName) {
                    renderDecks(categoryName);
                }
                if (!cardReviewView.classList.contains('hidden') && currentCategoryName === categoryName && currentDeckName) {
                    originalCards = [...(allCategories[categoryName]?.[currentDeckName]?.cards || [])];
                    currentCards = [...originalCards];
                    renderCardList(categoryName, currentDeckName);
                }
            } catch (err) {
                console.error('Error refreshing category from Firestore:', err);
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // --- DOM Elements ---
            const mainHeader = document.getElementById('main-header');
            const mainContent = document.getElementById('main-content');
            const categoryListView = document.getElementById('category-list-view');
            const deckListView = document.getElementById('deck-list-view');
            const cardReviewView = document.getElementById('card-review-view');
            const categoryListContainer = document.getElementById('category-list');
            const deckListContainer = document.getElementById('deck-list');
            const categoryTitle = document.getElementById('category-title');
            const deckTitle = document.getElementById('deck-title');
            const backToCategoriesBtn = document.getElementById('back-to-categories-btn');
            const backToDecksBtn = document.getElementById('back-to-decks-btn');
            const flashcardInner = document.getElementById('flashcard-inner');
            const cardFrontText = document.querySelector('#card-front p');
            const cardBackText = document.querySelector('#card-back p');
            const actionButtons = document.getElementById('action-buttons');
            const statusButtons = document.querySelectorAll('.status-btn');
            const shuffleBtn = document.getElementById('shuffle-btn');
            const searchInput = document.getElementById('search-input');
            const progressText = document.getElementById('card-progress-text');
            const progressBar = document.getElementById('card-progress-bar');
            const completionMessage = document.getElementById('completion-message');
            const restartDeckBtn = document.getElementById('restart-deck-btn');
            const generateExampleBtn = document.getElementById('generate-example-btn');
            const genExampleText = document.getElementById('gen-example-text');
            const genExampleSpinner = document.getElementById('gen-example-spinner');
            const exampleSentenceContainer = document.getElementById('example-sentence-container');
            // (legacy inline add-card elements removed) new card flow now uses modal inputs below
            const openAddCardModalBtn = document.getElementById('open-add-card-modal-btn');
            const addCardModal = document.getElementById('add-card-modal');
            const addCardModalContent = document.querySelector('#add-card-modal .modal-content');
            const cancelAddCardModalBtn = document.getElementById('cancel-add-card-modal-btn');
            const saveAddCardModalBtn = document.getElementById('save-add-card-modal-btn');
            const addCardFrontInput = document.getElementById('add-card-front');
            const addCardBackInput = document.getElementById('add-card-back');
            const editCategoryModal = document.getElementById('edit-category-modal');
            const editCategoryModalContent = document.querySelector('#edit-category-modal .modal-content');
            const cancelEditCategoryBtn = document.getElementById('cancel-edit-category-btn');
            const saveEditCategoryBtn = document.getElementById('save-edit-category-btn');
            const editCategoryNameInput = document.getElementById('edit-category-name-input');
            const startSessionContainer = document.getElementById('start-session-container');
            const startSessionBtn = document.getElementById('start-session-btn');
            const studyFocusView = document.getElementById('study-focus-view');
            const studySessionView = document.getElementById('study-session-view');
            const exitFocusModeBtn = document.getElementById('exit-focus-mode-btn');
            const cardListContainer = document.getElementById('card-list');
            const deckStatsContainer = document.getElementById('deck-stats');
            const editDeckNameBtn = document.getElementById('edit-deck-name-btn');
            const deleteDeckBtn = document.getElementById('delete-deck-btn');
            const showAddCategoryModalBtn = document.getElementById('show-add-category-modal-btn');
            const addCategoryModal = document.getElementById('add-category-modal');
            const addCategoryModalContent = document.querySelector('#add-category-modal .modal-content');
            const cancelAddCategoryBtn = document.getElementById('cancel-add-category-btn');
            const saveAddCategoryBtn = document.getElementById('save-add-category-btn');
            const addCategoryNameInput = document.getElementById('add-category-name-input');
            const showAddDeckModalBtn = document.getElementById('show-add-deck-modal-btn');
            const addDeckModal = document.getElementById('add-deck-modal');
            const addDeckModalContent = document.querySelector('#add-deck-modal .modal-content');
            const cancelAddDeckBtn = document.getElementById('cancel-add-deck-btn');
            const saveAddDeckBtn = document.getElementById('save-add-deck-btn');
            const addDeckNameInput = document.getElementById('add-deck-name-input');
            const editCardModal = document.getElementById('edit-card-modal');
            const editCardModalContent = document.querySelector('#edit-card-modal .modal-content');
            const cancelEditCardBtn = document.getElementById('cancel-edit-card-btn');
            const saveEditCardBtn = document.getElementById('save-edit-card-btn');
            const editCardFrontInput = document.getElementById('edit-card-front');
            const editCardBackInput = document.getElementById('edit-card-back');
            const editDeckModal = document.getElementById('edit-deck-modal');
            const editDeckModalContent = document.querySelector('#edit-deck-modal .modal-content');
            const cancelEditDeckBtn = document.getElementById('cancel-edit-deck-btn');
            const saveEditDeckBtn = document.getElementById('save-edit-deck-btn');
            const editDeckNameInput = document.getElementById('edit-deck-name-input');
            const confirmationModal = document.getElementById('confirmation-modal');
            const confirmationModalContent = document.querySelector('#confirmation-modal .modal-content');
            const confirmationMessage = document.getElementById('confirmation-message');
            const cancelConfirmationBtn = document.getElementById('cancel-confirmation-btn');
            const confirmDeleteBtn = document.getElementById('confirm-delete-btn');
            const themeToggle = document.getElementById('theme-toggle');
            const lightIcon = document.getElementById('theme-toggle-light-icon');
            const darkIcon = document.getElementById('theme-toggle-dark-icon');
            const importCardsBtn = document.getElementById('import-cards-btn');
            const exportCardsBtn = document.getElementById('export-cards-btn');
            const importCsvInput = document.getElementById('import-csv-input');

            // Start session button handler (restore functionality if missing)
            startSessionBtn.addEventListener('click', () => {
                if (!currentCategoryName || !currentDeckName) {
                    alert('Please select a deck before starting a study session.');
                    return;
                }
                updateDeckLastStudied(currentCategoryName, currentDeckName);
                mainContent.classList.add('hidden');
                mainHeader.classList.add('hidden');
                studyFocusView.classList.remove('hidden');
                renderCard();
            });

            // --- App State ---
            let currentCards = [];
            let originalCards = [];
            let currentCardIndex = 0;
            let cardBeingEdited = null;
            let confirmAction = null;

            // --- Gemini API Configuration ---
            const API_KEY = ""; // Leave empty
            const API_URL_GENERATE = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${API_KEY}`;
            
            async function generateExampleSentence(front, back) {
                const prompt = `Berikan satu contoh kalimat singkat dalam bahasa Inggris menggunakan kata "${front}" (yang artinya "${back}"). Sertakan juga terjemahan kalimatnya dalam bahasa Indonesia di baris baru. Format: Kalimat Inggris\nTerjemahan Indonesia`;
                const payload = { contents: [{ parts: [{ text: prompt }] }] };
                try {
                    const response = await fetch(API_URL_GENERATE, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const result = await response.json();
                    return result.candidates[0].content.parts[0].text;
                } catch (error) {
                    console.error("Error generating example sentence:", error);
                    return "Failed to generate example.";
                }
            }

            // --- Real-time Listeners ---
            function listenToCategories() {
                if (!userIsAuthenticated) return;
                const categoriesCollectionRef = collection(db, 'categories');
                onSnapshot(query(categoriesCollectionRef), (snapshot) => {
                    allCategories = {};
                    snapshot.forEach(doc => {
                        allCategories[doc.id] = {};
                    });
                    renderCategories();
                });
            }

            function listenToDecks(categoryName) {
                if (unsubscribeDecksListener) {
                    unsubscribeDecksListener();
                }
                const decksRef = collection(db, 'categories', categoryName, 'decks');
                unsubscribeDecksListener = onSnapshot(query(decksRef), (snapshot) => {
                    const decks = {};
                    snapshot.forEach(doc => {
                        decks[doc.id] = doc.data();
                    });
                    allCategories[categoryName] = decks;
                    
                    if (!deckListView.classList.contains('hidden')) {
                         renderDecks(categoryName);
                    }
                    
                    if (!cardReviewView.classList.contains('hidden') && allCategories[currentCategoryName]?.[currentDeckName]) {
                        originalCards = [...allCategories[currentCategoryName][currentDeckName].cards];
                        renderCardList(currentCategoryName, currentDeckName);

                        if (studyFocusView.classList.contains('hidden')) {
                            searchCards(searchInput.value);
                        } else {
                            const currentSearch = searchInput.value.toLowerCase();
                            currentCards = originalCards.filter(card => 
                                card.front.toLowerCase().includes(currentSearch) ||
                                card.back.toLowerCase().includes(currentSearch)
                            );
                        }
                    }
                });
            }

            // --- RENDERING ---
            const renderCategories = () => {
                categoryListContainer.innerHTML = '';
                const sortedCategoryNames = Object.keys(allCategories).sort();
                if (sortedCategoryNames.length === 0) {
                    categoryListContainer.innerHTML = `<p class="text-gray-500 dark:text-gray-400 col-span-full text-center">No categories yet. Click the + button to create one.</p>`;
                }
                sortedCategoryNames.forEach(categoryName => {
                    const categoryCard = document.createElement('div');
                    categoryCard.className = 'bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg hover:shadow-xl dark:shadow-none dark:hover:bg-gray-700/50 transition-shadow cursor-pointer relative';
                    categoryCard.dataset.categoryName = categoryName;
                    categoryCard.innerHTML = `
                        <div class="absolute top-2 right-2 flex gap-2">
                            <button data-category-name-edit="${categoryName}" class="edit-category-btn text-gray-400 hover:text-indigo-600"><i class="fas fa-pencil-alt"></i></button>
                            <button data-category-name-delete="${categoryName}" class="delete-category-btn text-gray-400 hover:text-red-600"><i class="fas fa-trash-alt"></i></button>
                        </div>
                        <h3 class="text-xl font-semibold text-indigo-700 dark:text-indigo-400 pointer-events-none">${categoryName}</h3>
                    `;
                    categoryListContainer.appendChild(categoryCard);
                    // Attach direct listener to the edit button so it reliably opens the edit modal
                    const editBtnElem = categoryCard.querySelector('.edit-category-btn');
                    if (editBtnElem) {
                        editBtnElem.addEventListener('click', (ev) => {
                            ev.stopPropagation();
                            const catName = editBtnElem.dataset.categoryNameEdit;
                            if (!catName) return;
                            editCategoryNameInput.value = catName;
                            showModal(editCategoryModal, editCategoryModalContent);
                            editCategoryModal._originalName = catName;
                        });
                    }
                });
            };

            const renderDecks = (categoryName) => {
                deckListContainer.innerHTML = '';
                const decks = allCategories[categoryName] || {};
                const sortedDeckNames = Object.keys(decks).sort();
                if (sortedDeckNames.length === 0) {
                    deckListContainer.innerHTML = `<p class="text-gray-500 dark:text-gray-400 col-span-full text-center">No decks in this category yet.</p>`;
                }
                sortedDeckNames.forEach(deckName => {
                    const deckData = decks[deckName];
                    const cardCount = deckData.cards.length;
                    let lastStudiedHTML = '';
                    if (deckData.lastStudied) {
                        const date = deckData.lastStudied.toDate();
                        const formattedDate = date.toLocaleDateString('en-US', { day: 'numeric', month: 'short', year: 'numeric' });
                        lastStudiedHTML = `<p class="text-xs text-gray-400 mt-2">Last studied: ${formattedDate}</p>`;
                    }

                    const deckCard = document.createElement('div');
                    deckCard.className = 'bg-white dark:bg-gray-800 p-6 rounded-xl shadow-lg hover:shadow-xl dark:shadow-none dark:hover:bg-gray-700/50 transition-shadow cursor-pointer';
                    deckCard.dataset.deckName = deckName;
                    deckCard.innerHTML = `
                        <h3 class="text-xl font-semibold text-indigo-700 dark:text-indigo-400 pointer-events-none">${deckName}</h3>
                        <p class="text-gray-500 dark:text-gray-400 mt-2 pointer-events-none">${cardCount} cards</p>
                        ${lastStudiedHTML}
                    `;
                    deckListContainer.appendChild(deckCard);
                });
            };

            const renderCardList = (categoryName, deckName) => {
                cardListContainer.innerHTML = '';
                // If we're currently viewing this deck and currentCards is set (e.g. search results), prefer that
                const isViewingThisDeck = currentCategoryName === categoryName && currentDeckName === deckName;
                const cards = (isViewingThisDeck && Array.isArray(currentCards) && currentCards.length >= 0)
                    ? currentCards
                    : (allCategories[categoryName]?.[deckName]?.cards || []);
                const statusColors = {
                    again: 'bg-red-400',
                    good: 'bg-blue-400',
                    easy: 'bg-green-400',
                    new: 'bg-gray-400'
                };
                if (cards.length === 0) {
                    cardListContainer.innerHTML = `<p class="text-gray-500 dark:text-gray-400 text-center">No cards in this deck yet.</p>`;
                }
                cards.forEach((card, index) => {
                    const cardItem = document.createElement('div');
                    cardItem.className = 'flex justify-between items-center p-2 border-b dark:border-gray-700';
                    const statusColor = statusColors[card.status] || 'bg-gray-400';
                    const escapeHtml = (s) => String(s || '')
                        .replace(/&/g, '&amp;')
                        .replace(/</g, '&lt;')
                        .replace(/>/g, '&gt;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                    const nl2br = (s) => escapeHtml(s).replace(/\r?\n/g, '<br>');
                    cardItem.innerHTML = `
                        <div class="flex items-center gap-3">
                           <span class="w-3 h-3 rounded-full ${statusColor}"></span>
                           <span>${nl2br(card.front)}</span>
                        </div>
                        <div class="flex gap-2">
                            <button data-card-index="${index}" class="edit-card-btn text-gray-400 hover:text-indigo-600"><i class="fas fa-pencil-alt"></i></button>
                            <button data-card-index="${index}" class="delete-card-btn text-gray-400 hover:text-red-600"><i class="fas fa-trash-alt"></i></button>
                        </div>
                    `;
                    cardListContainer.appendChild(cardItem);
                });

                // Attach handlers for status buttons (Again/Good/Easy) in study view
                const statusBtns = document.querySelectorAll('.status-btn');
                statusBtns.forEach(btn => {
                    btn.removeEventListener('click', btn._statusHandler);
                    const handler = () => handleStatusUpdate(btn.dataset.status);
                    btn.addEventListener('click', handler);
                    btn._statusHandler = handler;
                });

                // Render Stats
                const stats = { again: 0, good: 0, easy: 0, new: 0, total: cards.length };
                cards.forEach(card => {
                    stats[card.status || 'new']++;
                });
                deckStatsContainer.innerHTML = `
                    <div><p class="text-2xl font-bold text-gray-700 dark:text-gray-300">${stats.total}</p><p class="text-sm text-gray-500 dark:text-gray-400">Total</p></div>
                    <div><p class="text-2xl font-bold text-green-500">${stats.easy}</p><p class="text-sm text-gray-500 dark:text-gray-400">Easy</p></div>
                    <div><p class="text-2xl font-bold text-blue-500">${stats.good}</p><p class="text-sm text-gray-500 dark:text-gray-400">Good</p></div>
                    <div><p class="text-2xl font-bold text-red-500">${stats.again}</p><p class="text-sm text-gray-500 dark:text-gray-400">Again</p></div>
                    <div><p class="text-2xl font-bold text-gray-500">${stats.new}</p><p class="text-sm text-gray-500 dark:text-gray-400">New</p></div>
                `;
            };

            const renderCard = () => {
                updateProgress();
                flashcardInner.classList.remove('is-flipped');
                actionButtons.classList.add('hidden');
                completionMessage.classList.add('hidden');
                exampleSentenceContainer.classList.add('hidden');
                exampleSentenceContainer.innerHTML = '';
                if (currentCards.length === 0) {
                    cardFrontText.textContent = "This deck is empty. Add a new card above.";
                    cardBackText.textContent = "";
                    document.getElementById('flashcard-container').classList.remove('hidden');
                    return;
                }
                if (currentCardIndex >= currentCards.length) {
                    showCompletionMessage();
                    return;
                }
                const card = currentCards[currentCardIndex];
                // Preserve newlines entered in textareas: escape HTML then replace \n with <br>
                const escapeHtml = (str) => String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
                const nl2br = (s) => escapeHtml(s).replace(/\r?\n/g, '<br>');

                cardFrontText.innerHTML = nl2br(card.front || '');
                cardBackText.innerHTML = nl2br(card.back || '');
            };
            
            const showCompletionMessage = () => {
                completionMessage.classList.remove('hidden');
                document.getElementById('flashcard-container').classList.add('hidden');
                progressText.textContent = `Finished! ${originalCards.length} of ${originalCards.length} cards.`;
                // Offer user to go back to the card list automatically after short delay
                const backBtn = document.getElementById('back-to-cards-after-study-btn');
                if (backBtn) {
                    // ensure handler exists
                    backBtn.addEventListener('click', exitStudyAndReturnToCards);
                }
                // Auto-return after 1.5s for faster flow
                setTimeout(() => {
                    exitStudyAndReturnToCards();
                }, 1500);
            }

            function exitStudyAndReturnToCards() {
                // hide study views
                studyFocusView.classList.add('hidden');
                studySessionView.classList.add('hidden');
                // show card list view
                mainContent.classList.remove('hidden');
                mainHeader.classList.remove('hidden');
                // navigate to the current deck's card list
                if (currentCategoryName && currentDeckName) {
                    cardReviewView.classList.remove('hidden');
                    deckListView.classList.add('hidden');
                    renderCardList(currentCategoryName, currentDeckName);
                }
            }

            const updateProgress = () => {
                const total = originalCards.length;
                const current = Math.min(currentCardIndex + 1, total);
                if (total === 0) {
                    progressText.textContent = "No cards in this deck.";
                    progressBar.style.width = '0%';
                    return;
                }
                document.getElementById('flashcard-container').classList.remove('hidden');
                if (currentCardIndex >= currentCards.length) {
                     progressText.textContent = `Finished! ${total} of ${total} cards.`;
                     progressBar.style.width = `100%`;
                } else {
                    progressText.textContent = `Card ${current} of ${total}`;
                    progressBar.style.width = `${(current / total) * 100}%`;
                }
            };

            // --- APP LOGIC & NAVIGATION ---
            const selectCategory = (categoryName) => {
                currentCategoryName = categoryName;
                categoryTitle.textContent = categoryName;
                listenToDecks(categoryName);
                categoryListView.classList.add('hidden');
                deckListView.classList.remove('hidden');
            };

            const selectDeck = (categoryName, deckName) => {
                currentCategoryName = categoryName;
                currentDeckName = deckName;
                originalCards = [...allCategories[categoryName][deckName].cards];
                currentCards = [...originalCards];
                currentCardIndex = 0;
                deckTitle.textContent = deckName;
                searchInput.value = '';
                
                renderCardList(categoryName, deckName);

                deckListView.classList.add('hidden');
                cardReviewView.classList.remove('hidden');
                
                studyFocusView.classList.add('hidden');
                startSessionContainer.classList.remove('hidden');
                completionMessage.classList.add('hidden');
            };
            
            const restartDeck = () => {
                currentCards = [...originalCards];
                currentCardIndex = 0;
                renderCard();
            }

            const flipCard = () => {
                if (currentCards.length > 0 && currentCardIndex < currentCards.length) {
                    flashcardInner.classList.toggle('is-flipped');
                    actionButtons.classList.toggle('hidden');
                }
            };
            
            const handleStatusUpdate = (status) => {
                const cardToUpdate = currentCards[currentCardIndex];
                const originalIndex = originalCards.findIndex(c => c.front === cardToUpdate.front && c.back === cardToUpdate.back);
                if (originalIndex !== -1) {
                    updateCardStatusInFirestore(currentCategoryName, currentDeckName, originalIndex, status);
                }
                
                if (flashcardInner.classList.contains('is-flipped')) {
                    flashcardInner.classList.remove('is-flipped');
                    actionButtons.classList.add('hidden');
                    setTimeout(() => {
                        currentCardIndex++;
                        renderCard();
                    }, 300); 
                } else {
                    currentCardIndex++;
                    renderCard();
                }
            };
            
            const shuffleCards = () => {
                for (let i = currentCards.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentCards[i], currentCards[j]] = [currentCards[j], currentCards[i]];
                }
                currentCardIndex = 0;
                renderCard();
            };

            const searchCards = (query) => {
                const lowerCaseQuery = String(query || '').toLowerCase();
                currentCards = originalCards.filter(card => 
                    card.front.toLowerCase().includes(lowerCaseQuery) ||
                    card.back.toLowerCase().includes(lowerCaseQuery)
                );
                currentCardIndex = 0;
                // If study focus is visible, update the flashcard; otherwise update the card list view
                if (!studyFocusView.classList.contains('hidden')) {
                    renderCard();
                } else {
                    renderCardList(currentCategoryName, currentDeckName);
                }
            };

            // --- Modal Logic ---
            const showModal = (modal, content) => {
                modal.classList.remove('hidden');
                setTimeout(() => {
                    modal.classList.remove('opacity-0');
                    content.classList.remove('scale-95');
                }, 10);
            };

            const hideModal = (modal, content) => {
                modal.classList.add('opacity-0');
                content.classList.add('scale-95');
                setTimeout(() => {
                    modal.classList.add('hidden');
                }, 250);
            };

            const showConfirmationModal = (message, onConfirm) => {
                confirmationMessage.textContent = message;
                confirmAction = onConfirm;
                showModal(confirmationModal, confirmationModalContent);
            };

            // --- EVENT LISTENERS ---
            showAddCategoryModalBtn.addEventListener('click', () => {
                addCategoryNameInput.value = '';
                showModal(addCategoryModal, addCategoryModalContent);
            });

            showAddDeckModalBtn.addEventListener('click', () => {
                addDeckNameInput.value = '';
                showModal(addDeckModal, addDeckModalContent);
            });

            // legacy inline add-card handler removed; use modal-based add below

            // Open Add Card Modal
            if (openAddCardModalBtn) openAddCardModalBtn.addEventListener('click', () => {
                addCardFrontInput.value = '';
                addCardBackInput.value = '';
                showModal(addCardModal, addCardModalContent);
            });
            if (cancelAddCardModalBtn) cancelAddCardModalBtn.addEventListener('click', () => hideModal(addCardModal, addCardModalContent));
            if (saveAddCardModalBtn) saveAddCardModalBtn.addEventListener('click', async () => {
                const front = addCardFrontInput.value.trim();
                const back = addCardBackInput.value.trim();
                if (!front || !back || !currentDeckName) {
                    alert('Please enter both front and back and select a deck.');
                    return;
                }
                await addCardToFirestore(currentCategoryName, currentDeckName, front, back);
                hideModal(addCardModal, addCardModalContent);
            });

            // edit-category handled by per-button listeners attached in renderCategories

            if (cancelEditCategoryBtn) cancelEditCategoryBtn.addEventListener('click', () => hideModal(editCategoryModal, editCategoryModalContent));
            if (saveEditCategoryBtn) saveEditCategoryBtn.addEventListener('click', async () => {
                const newName = editCategoryNameInput.value.trim();
                const original = editCategoryModal._originalName;
                if (!newName || !original) {
                    alert('Invalid category name.');
                    return;
                }
                if (newName === original) {
                    hideModal(editCategoryModal, editCategoryModalContent);
                    return;
                }
                try {
                    saveEditCategoryBtn.disabled = true;
                    console.log('Renaming category', original, '->', newName);
                    const ok = await updateCategoryNameInFirestore(original, newName);
                    console.log('Rename result:', ok);
                    if (ok) {
                        hideModal(editCategoryModal, editCategoryModalContent);
                    }
                } catch (err) {
                    console.error('Error during category rename:', err);
                    alert('Error renaming category. See console for details.');
                } finally {
                    saveEditCategoryBtn.disabled = false;
                }
            });

            backToCategoriesBtn.addEventListener('click', () => {
                if (unsubscribeDecksListener) unsubscribeDecksListener();
                deckListView.classList.add('hidden');
                categoryListView.classList.remove('hidden');
                currentCategoryName = '';
            });

            backToDecksBtn.addEventListener('click', () => {
                cardReviewView.classList.add('hidden');
                deckListView.classList.remove('hidden');
                currentDeckName = ''; 
            });
            
            categoryListContainer.addEventListener('click', (e) => {
                const categoryCard = e.target.closest('[data-category-name]');
                const deleteBtn = e.target.closest('.delete-category-btn');

                if (deleteBtn) {
                    e.stopPropagation(); // Prevent card click
                    const categoryName = deleteBtn.dataset.categoryNameDelete;
                    showConfirmationModal(`Are you sure you want to delete the category "${categoryName}" and all decks within it?`, () => {
                        deleteCategoryFromFirestore(categoryName);
                    });
                    return;
                }

                if (categoryCard) {
                    selectCategory(categoryCard.dataset.categoryName);
                }
            });

            deckListContainer.addEventListener('click', (e) => {
                const deckCard = e.target.closest('[data-deck-name]');
                if (deckCard) {
                    selectDeck(currentCategoryName, deckCard.dataset.deckName);
                }
            });

            exportCardsBtn.addEventListener('click', () => {
                if (!currentCategoryName || !currentDeckName) {
                    alert('Please select a deck before exporting cards.');
                    return;
                }
                const cards = allCategories[currentCategoryName]?.[currentDeckName]?.cards || [];
                if (cards.length === 0) {
                    alert('This deck has no cards to export.');
                    return;
                }

                const rows = cards.map(c => ({ front: c.front, back: c.back, status: c.status || 'new' }));

                // Prefer exporting as XLSX if SheetJS is available
                if (typeof XLSX !== 'undefined') {
                    try {
                        const ws = XLSX.utils.json_to_sheet(rows, { header: ['front', 'back', 'status'] });
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, 'Cards');
                        const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                        const blob = new Blob([wbout], { type: 'application/octet-stream' });
                        const link = document.createElement('a');
                        const url = URL.createObjectURL(blob);
                        link.href = url;
                        link.download = `${currentDeckName.replace(/[^a-z0-9_\-]/gi, '_')}_cards.xlsx`;
                        link.style.visibility = 'hidden';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                        return;
                    } catch (err) {
                        console.error('XLSX export failed, falling back to CSV:', err);
                        // fallback to CSV below
                    }
                }

                // CSV fallback (PapaParse or manual)
                let csv = '';
                if (typeof Papa !== 'undefined' && Papa.unparse) {
                    csv = Papa.unparse(rows);
                } else {
                    // Fallback CSV generation if PapaParse isn't loaded
                    const escapeCell = (v) => `"${String(v).replace(/"/g, '""')}"`;
                    const header = ['front','back','status'];
                    const lines = [header.join(',')].concat(rows.map(r => [escapeCell(r.front), escapeCell(r.back), escapeCell(r.status)].join(',')));
                    csv = lines.join('\r\n');
                }

                // Add BOM to help Excel detect utf-8
                const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = `${currentDeckName.replace(/[^a-z0-9_\-]/gi, '_')}_cards.csv`;
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            });

            generateExampleBtn.addEventListener('click', async () => {
                if (currentCards.length === 0) return;
                const card = currentCards[currentCardIndex];
                genExampleSpinner.classList.remove('hidden');
                genExampleText.textContent = 'Generating...';
                generateExampleBtn.disabled = true;
                const example = await generateExampleSentence(card.front, card.back);
                exampleSentenceContainer.innerHTML = String(example).replace(/\n/g, '<br>');
                exampleSentenceContainer.classList.remove('hidden');
                genExampleSpinner.classList.add('hidden');
                genExampleText.textContent = 'âœ¨ Generate Example';
                generateExampleBtn.disabled = false;
            });

            // Restore/ensure shuffle, exit focus, and search input listeners
            if (shuffleBtn) shuffleBtn.addEventListener('click', shuffleCards);
            if (exitFocusModeBtn) exitFocusModeBtn.addEventListener('click', () => {
                studyFocusView.classList.add('hidden');
                mainContent.classList.remove('hidden');
                mainHeader.classList.remove('hidden');
                selectDeck(currentCategoryName, currentDeckName);
            });
            if (searchInput) searchInput.addEventListener('input', (e) => searchCards(e.target.value));
            // Flip card when clicking on the flashcard container (but not on control buttons)
            if (flashcardInner) {
                flashcardInner.addEventListener('click', (e) => {
                    if (!e.target.closest('button')) flipCard();
                });
            }

            deleteDeckBtn.addEventListener('click', () => {
                showConfirmationModal(`Are you sure you want to delete the deck "${currentDeckName}"?`, () => {
                    deleteDeckFromFirestore(currentCategoryName, currentDeckName);
                });
            });

            editDeckNameBtn.addEventListener('click', () => {
                editDeckNameInput.value = currentDeckName;
                showModal(editDeckModal, editDeckModalContent);
            });

            cardListContainer.addEventListener('click', (e) => {
                const editBtn = e.target.closest('.edit-card-btn');
                const deleteBtn = e.target.closest('.delete-card-btn');

                if (editBtn) {
                    const cardIndex = parseInt(editBtn.dataset.cardIndex, 10);
                    cardBeingEdited = allCategories[currentCategoryName][currentDeckName].cards[cardIndex];
                    editCardFrontInput.value = cardBeingEdited.front;
                    editCardBackInput.value = cardBeingEdited.back;
                    showModal(editCardModal, editCardModalContent);
                }

                if (deleteBtn) {
                    const cardIndex = parseInt(deleteBtn.dataset.cardIndex, 10);
                    const card = allCategories[currentCategoryName][currentDeckName].cards[cardIndex];
                    showConfirmationModal(`Delete card "${card.front}"?`, () => {
                        deleteCardFromFirestore(currentCategoryName, currentDeckName, card);
                    });
                }
            });

            saveAddCategoryBtn.addEventListener('click', () => {
                const newName = addCategoryNameInput.value.trim();
                if (newName && !allCategories[newName]) {
                    addCategoryToFirestore(newName);
                    hideModal(addCategoryModal, addCategoryModalContent);
                } else if (allCategories[newName]) {
                    alert('A category with this name already exists.');
                }
            });
            cancelAddCategoryBtn.addEventListener('click', () => hideModal(addCategoryModal, addCategoryModalContent));

            saveAddDeckBtn.addEventListener('click', () => {
                const newName = addDeckNameInput.value.trim();
                if (newName && (!allCategories[currentCategoryName] || !allCategories[currentCategoryName][newName])) {
                    addDeckToFirestore(currentCategoryName, newName);
                    hideModal(addDeckModal, addDeckModalContent);
                } else if (allCategories[currentCategoryName] && allCategories[currentCategoryName][newName]) {
                    alert('A deck with this name already exists.');
                }
            });
            cancelAddDeckBtn.addEventListener('click', () => hideModal(addDeckModal, addDeckModalContent));
            
            saveEditCardBtn.addEventListener('click', () => {
                const newFront = editCardFrontInput.value.trim();
                const newBack = editCardBackInput.value.trim();
                if (newFront && newBack && cardBeingEdited) {
                    const newCard = { front: newFront, back: newBack, status: cardBeingEdited.status || 'new' };
                    updateCardInFirestore(currentCategoryName, currentDeckName, cardBeingEdited, newCard);
                    hideModal(editCardModal, editCardModalContent);
                }
            });
            cancelEditCardBtn.addEventListener('click', () => hideModal(editCardModal, editCardModalContent));

            saveEditDeckBtn.addEventListener('click', () => {
                const newName = editDeckNameInput.value.trim();
                if (newName) {
                    updateDeckNameInFirestore(currentCategoryName, currentDeckName, newName);
                    hideModal(editDeckModal, editDeckModalContent);
                }
            });
            cancelEditDeckBtn.addEventListener('click', () => hideModal(editDeckModal, editDeckModalContent));

            confirmDeleteBtn.addEventListener('click', () => {
                if (confirmAction) {
                    confirmAction();
                }
                hideModal(confirmationModal, confirmationModalContent);
            });
            cancelConfirmationBtn.addEventListener('click', () => hideModal(confirmationModal, confirmationModalContent));
            
            // Dark Mode Toggle
            themeToggle.addEventListener('click', () => {
                document.documentElement.classList.toggle('dark');
                if (document.documentElement.classList.contains('dark')) {
                    localStorage.setItem('theme', 'dark');
                    lightIcon.classList.add('hidden');
                    darkIcon.classList.remove('hidden');
                } else {
                    localStorage.setItem('theme', 'light');
                    lightIcon.classList.remove('hidden');
                    darkIcon.classList.add('hidden');
                }
            });

            // Set initial icon for dark mode
            if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                lightIcon.classList.add('hidden');
                darkIcon.classList.remove('hidden');
            } else {
                lightIcon.classList.remove('hidden');
                darkIcon.classList.add('hidden');
            }
            
            // Import/Export Listeners
            importCardsBtn.addEventListener('click', () => {
                if (!currentCategoryName || !currentDeckName) {
                    alert('Please select a deck before importing cards.');
                    return;
                }
                importCsvInput.click();
            });

            exportCardsBtn.addEventListener('click', () => {
                if (!currentCategoryName || !currentDeckName) {
                    alert('Please select a deck before exporting cards.');
                    return;
                }
                const cards = allCategories[currentCategoryName]?.[currentDeckName]?.cards || [];
                if (cards.length === 0) {
                    alert('This deck has no cards to export.');
                    return;
                }

                const rows = cards.map(c => ({ front: c.front, back: c.back, status: c.status || 'new' }));
                let csv = '';
                if (typeof Papa !== 'undefined' && Papa.unparse) {
                    csv = Papa.unparse(rows);
                } else {
                    // Fallback CSV generation if PapaParse isn't loaded
                    const escapeCell = (v) => `"${String(v).replace(/"/g, '""')}"`;
                    const header = ['front','back','status'];
                    const lines = [header.join(',')].concat(rows.map(r => [escapeCell(r.front), escapeCell(r.back), escapeCell(r.status)].join(',')));
                    csv = lines.join('\r\n');
                }

                // Add BOM to help Excel detect utf-8
                const blob = new Blob(['\uFEFF' + csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const url = URL.createObjectURL(blob);
                link.href = url;
                link.download = `${currentDeckName.replace(/[^a-z0-9_\-]/gi, '_')}_cards.csv`;
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            });

            importCsvInput.addEventListener('change', (event) => {
                if (!currentCategoryName || !currentDeckName) {
                    alert('Please select a deck before importing cards.');
                    event.target.value = '';
                    return;
                }

                const file = event.target.files[0];
                if (!file) return;

                // Helper: parse using SheetJS for Excel, Papa for CSV, otherwise a minimal CSV parser
                const parseFile = (f) => {
                    const name = f.name || '';
                    const lower = name.toLowerCase();

                    const isExcel = lower.endsWith('.xlsx') || lower.endsWith('.xls') || f.type === 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' || f.type === 'application/vnd.ms-excel';
                    if (isExcel && typeof XLSX !== 'undefined') {
                        return f.arrayBuffer().then(ab => {
                            const workbook = XLSX.read(ab, { type: 'array' });
                            const sheetName = workbook.SheetNames[0];
                            const worksheet = workbook.Sheets[sheetName];

                            // Read as arrays so we can detect whether the first row is headers
                            const rows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                            if (!rows || rows.length === 0) return { data: [] };

                            // Detect header row: if any cell in first row matches common header names
                            const firstRow = rows[0].map(c => String(c).trim().toLowerCase());
                            const headerCandidates = ['front','question','term','back','answer','definition','status'];
                            const firstRowLooksLikeHeader = firstRow.some(cell => headerCandidates.includes(cell));

                            if (firstRowLooksLikeHeader) {
                                // Convert using the first row as header
                                const json = XLSX.utils.sheet_to_json(worksheet, { defval: '' });
                                return { data: json };
                            }

                            // Otherwise treat rows as data (no header). Map columns: 0=front,1=back,2=status
                            const data = rows.map(r => ({
                                front: r[0] !== undefined ? String(r[0]).trim() : '',
                                back: r[1] !== undefined ? String(r[1]).trim() : '',
                                status: r[2] !== undefined ? String(r[2]).trim() : ''
                            }));

                            return { data };
                        });
                    }

                    if (typeof Papa !== 'undefined' && Papa.parse) {
                        return new Promise((resolve, reject) => {
                            Papa.parse(f, {
                                header: true,
                                skipEmptyLines: true,
                                complete: (results) => resolve(results),
                                error: (err) => reject(err)
                            });
                        });
                    }

                    // Minimal CSV parse fallback (assumes comma-separated, first line header)
                    return f.text().then(text => {
                        const lines = text.split(/\r?\n/).filter(l => l.trim());
                        if (lines.length === 0) return { data: [] };
                        const headers = lines.shift().split(',').map(h => h.trim());
                        const data = lines.map(line => {
                            const cols = line.split(',');
                            const obj = {};
                            headers.forEach((h, i) => obj[h] = (cols[i] || '').trim());
                            return obj;
                        });
                        return { data };
                    });
                };

                (async () => {
                    try {
                        const results = await parseFile(file);
                        const imported = results.data || [];
                        if (imported.length === 0) {
                            alert('No rows found in CSV.');
                            return;
                        }

                        // Normalize keys (case-insensitive) and support common header names
                        const normalizeRow = (row) => {
                            const keys = Object.keys(row);
                            const findKey = (candidates) => keys.find(k => candidates.some(c => new RegExp(`^${c}$`, 'i').test(k)));
                            const frontKey = findKey(['front', 'question', 'term']) || keys[0];
                            const backKey = findKey(['back', 'answer', 'definition']) || keys[1] || keys[0];
                            return {
                                front: row[frontKey] ? String(row[frontKey]).trim() : '',
                                back: row[backKey] ? String(row[backKey]).trim() : ''
                            };
                        };

                        const rowsToImport = imported.map(normalizeRow).filter(r => r.front && r.back);
                        if (rowsToImport.length === 0) {
                            alert('No valid rows found. Ensure the CSV has "front" and "back" columns.');
                            return;
                        }

                        let success = 0;
                        for (const r of rowsToImport) {
                            try {
                                await addCardToFirestore(currentCategoryName, currentDeckName, r.front, r.back);
                                success++;
                            } catch (err) {
                                console.error('Failed to import row', r, err);
                            }
                        }

                        alert(`${success} of ${rowsToImport.length} cards imported successfully!`);
                    } catch (err) {
                        console.error('Error parsing/importing CSV:', err);
                        alert('Failed to parse or import CSV. Check console for details.');
                    } finally {
                        event.target.value = '';
                    }
                })();
            });

            // --- INITIAL AUTHENTICATION & DATA LOAD ---
            setPersistence(auth, browserLocalPersistence)
                .then(() => {
                    onAuthStateChanged(auth, (user) => {
                        if (user) {
                            userIsAuthenticated = true;
                            listenToCategories();
                        } else {
                            signInAnonymously(auth).catch((error) => {
                                console.error("Anonymous sign-in failed:", error);
                            });
                        }
                    });
                })
                .catch((error) => {
                    console.error("Error setting persistence:", error);
                });
        });
    </script>
    <script>
        // Register service worker if supported
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js')
            .then(reg => {
                console.log('Service worker registered.', reg);
            }).catch(err => console.error('SW registration failed:', err));
        }
    </script>
</body>
</html>
